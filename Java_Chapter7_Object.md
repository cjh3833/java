# 객체지향 프로그래밍 II
## 상속
### 상속의 정의와 장점
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 새로 만든 클래스 이름 뒤에 extends + 상속하고자 하는 클래스이름

<br>
class Child extends Parent{<br>...<br>}

<br>

- 상속해주는 클래스를 '조상클래스'
- 상속받는 클래스를 '자손클래스'

- 조상클래스 : 부모클래스, 상위클래스, 기반클래스
- 자손클래스 : 자신클래스, 하위클래스, 파생된 클래스

- 클래스간의 상속 관계는 화살표로 표시, 클래스 간의 상속관계를 긂으로 표현한 것을 상속계층도라고 함

- 자손 클래스는 조상클래스의 모든 멤버를 상속받는다

--- 

- 생성자와 초기화 블럭은 상속되지 않는다, 멤버만 상속된다
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다

- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성

<br><br>

### 클래스 간의 관계 - 포함관계
- 상속이외에도 클래스 재사용하는 방법은 클래스간의 포함관계를 만들어주는 것
- 클래스 간 포함관계는 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것


class Circle{<br>int x;<br>int y;<br>iny r;<br>}

<br>

class Point{<br>int x; <br> int y;<br>}

이렇게 클래스가 있으면

class Circle{<br>Point c = new Point(); <br> int r;<br>}

이런식으로 작성 가능 (단위별로 여러개의 클래스 작성한 다음 단위클래스들을 포함관계로 재사용하면 코드가 간결, 손쉽게 클래스작성)
<br><br>
ex) Car 클래스를 작성할 때 단위구성요소인 Engine, Door등등의 클래스 작성 후 Car클래스 멤버변수로 선언해 포함으로 만들어주면 보기 좋다

<br><br>

### 클래스간의 관계 결정하기
- ~은 ~이다(is - a), ~은 ~을 가지고 있다(has ~ a)를 넣어서 문장을 만들면 클래스간 상속 or 포함 관계가 명확해진다<br><br>
  
---
- 원은 점이다 - Circle is a Point (상속)
- 원은 점을 가지고 있다 - Circle has a Point (포함)
---

<br>
- 조상클래스에 정의된 메서드와 같은 메서드를 자손 클래스에 정의하는 것을 '오버라이딩'이라고 한다

### 단일 상속
- 자바에서는 단일 상속만 가능
- 2가지를 할 경우, 상속 후 포함해주면 된다

<br><br>

### Object클래스 - 모든 클래스의 조상
- 모든 상속계층도 최상위에는 Object클래스가 위치


<br><br>

## 오버라이딩
### 오버라이딩이란
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
  
- override (~위에 덮어쓰다)

- 상속받은 메서드를 그대로 사용하기도 하지만 자손 클래스에 맞게 변경하는 것을 조상의 메서드를 오버라이딩한다

<br><br>

### 오버라이딩의 조건
자손클래스에서 오버라이딩 하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다
- 매개변수가 같아야 한다
- 반환타입이 같아야 한다

<br> 선언부가 서로 일치해야 한다

<br>

1. 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
2. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다

<br>

조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때
1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다
3. 인스턴스 메서드를 static메서드 또는 그 반대로 변경할 수 없다

<br><br>

- 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static메서드로 정의할 수 있지만 이건 각 클래스에 별개의 static메서드를 정의한 것, 오버라이딩은 아님

- static멤버들은 자신들이 정의된 클래스에 묶여있다고 생각

<br><br>

### 오버로딩 vs. 오버라이딩
- 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것(New)
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것(Change, Modify)

<br><br>

### super
- 자손클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조변수

- this를 붙여 멤버변수, 지역변수를 구분했듯 상속받은 멤버와 자신의 멤버가 이름이 같을 때 super를 붙여 구별가능

- 조상의 멤버와 자신의 멤버를 구별한다는 점을 제외하면 this, super는 근본적으로 같다

- this와 마찬가지로 super도 static메서드에서 사용할 수 없고 인스턴스 메서드에서만 사용가능

<br><br>

### super() - 조상클래스의 생성자
- this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만 super()는 조상 클래스의 생성자를 호출하는데 사용된다

- Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야함, 그렇지 않을 경우 컴파일러가 생성자의 첫 줄에 super();를 자동으로 추가

<br>

인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요하다
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

<br>

- 조상클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야한다

<br><br>

## package와 import
### 패키지(package)
- 패키지란 클래스의 묶음
  
- 클래스가 물리적으로 하나의 클래스파일(.class) 인것과 같이 패키지는 물리적으로 하나의 디렉토리
<br><br><br>

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리

<br><br>

### 패키지의 선언
- package 패키지명;

<br>

- 패키지는 반드시 소스파일에서 주석, 공백을 제외한 첫 번째 문장이여야 한다, 하나의 소스파일에는 단 한번만 선언가능

<br><br>

### import문
- import문은 컴파일러한테 소스파일에 사용된 클래스의 패키지 정보를 제공

- import 선언 방법
  - import 패키지명.클래스명;
  - import 패키지명.*;

<br><br>

### static import문
- static멤버를 호출할 때 클래스 이름을 생략가능

<br><br>

## 제어자

제어자는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다

- 접근 제어자 - public, protected, default, private

<br>
접근 제어자는 한 번에 네 가지 중 하나만 사용 가능하다

<br><br>

### static - 클래스의, 공통적인
static은 '클래스의' 또는 '공통적인' 이란 의미를 가진다<br>
- 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가진다<br>(하나의 변수를 모든 인스턴스가 공유하기 때문)<br>

- static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

<br><br>

### final - 마지막의, 변경될 수 없는
- 변수에 사용되면 바꿀 수 없는 상수가 된다
- 메서드에 사용되면 오버라이딩을 할 수 없다
- 클래스에 사용되면 자손클래스를 정의하지 못하게 된다

<br><br>

- final이 붙은 변수는 일반적으로 선언과 초기화를 동시에 하지만<br>인스턴스 변수의 경우 생성자에서 초기화 할 수 있다
  - 이 기능을 쓰면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 가지게 가능하다

<br><br>

### abstract - 추상의, 미완성의
- 메서드의 선언만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용

<br>

- abstract가 사용될 수 있는 곳 - 클래스, 메서드
- 추상클래스는 아직 완성되지않은 메서드가 있는 미완성 설계도이므로 인스턴스를 생성할 수 없다

<br><br>

### 접근 제어자
- 멤버 또는 클래스에 사용, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한

  private | default | protected | public
  --- | --- | --- | ---
  같은 클래스 내에서만 접근 가능 | 같은 패키지 내에서만 접근 가능 | 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근가능 | 접근 제한이 없다


  <br>

- public > protect > default > private

- 클래스 : public, default
- 메서드,멤버변수 : public, protected, (default), private
- 지역변수 : 사용불가

<br>

접근 제어자를 이용한 캡슐화
- 클래스, 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에서 선언된 데이터를 보호
- 이를 객체지향개념의 캡슐화 라고 한다

<br>

- (참고) 멤버변수의 값을 읽는 메서드의 이름을 'get멤버변수이름'<br>멤버변수의 값을 변경하는 메서드의 이름을 'set멤버변수이름'

- 간접적으로 private 데이터를 수정하는 방법 책350p, 예제 7-13 참고

<br><br>

### 생성자의 접근 제어자
- 생성자의 접근 제어자를 private로 지정하면 외부에서 접근이 안되므로 인스턴스를 생성할 수 없다 (클래스 내부에서는 생성가능)
- 대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공하므로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다
  - 이 메서드는 public인 동시에 static이여야한다

- 이처럼 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다

<br><br>

### 제어자의 조합
- 클래스 : public, (default), final, abstract
- 메서드 : 모든 접근 제어자, final, abstract, static
- 멤버변수 : 모든 접근 제어자, final, static
- 지역변수 : final

<br><br>
제어자를 조합하여 사용할 때 주의해야할 사항

1. 메서드에서 static과 abstract를 함께 사용할 수 없다
2. 클래스에서 abstract와 final을 동시에 사용할 수 없다
3. abstract메서드의 접근 제어자가 private일 수 없다
4. 메서드에 private와 final을 같이 사용할 필요는 없다

<br><br>

## 다형성
### 다형성이란?
- 변수에 static 키워드가 붙어있으면 클래스의 멤버가 된다

- 여러 가지 형태를 가질 수 있는 능력, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로 다형성을 구현

- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있게 함

<br><br>
TV(조상클래스), CaptionTv(자식클래스)<br><br>
TV와 CaptionTV클래스가 서로 상속관계에 있을 경우 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조하도록 하는것이 가능

- Caption c = new Caption();
- Tv t = new CaptionTv();

<br>
TV타입의 참조변수는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들만 사용할 수 있다<br><br> 즉, t.text 또는 t.caption()등과 같이 만들 수 없다
<br><br>

- 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다
- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야한다


<br><br>
1. 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다
2. 반대는 안된다
<br><br>

### 참조변수의 형변환
- 참조형 변수도 형변환이 가능하지만 서로 상속관계에 있는 클래스 사이에서만 가능

- 자손 타입 -> 조상타입   : 형변환 생략가능 (Up-Casting)
- 자손 타입 <- 조상타입   : 형변환 생략 불가능(Down-Casting)

<br>
기본형 변수의 형변환에서 작은 -> 큰 자료형의 형변환이 생략가능하듯 이것도 같다<br><br>
캐스팅 연산자를 사용, 괄호안에 변환하고자 하는 타입의 이름(클래스명)을 적어주면 된다
<br><br>

- 형변환은 참조변수의 타입을 변환하는 것
- 참조변수의 형변환을 통해서 참조하고있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절

<br><br>
1. 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭다<br>참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용x<br>그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요
<br><br><br>

## instanceof 연산자
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자 사용
- 주로 조건문에서 사용
- instanceof 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 피연산자로 위치
- 연산결과로 boolean 형식의 값 반환

if (c instanceof FireEngine) { }


- 조상의 멤버들을 상속받으면 FireEngine인스턴스에 Object, Car인스턴스를 포함하고 있는 뜻이니 instanceof결과값 true, 형변환해도 문제없다
<br><br>

1. 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 말함

<br><br>

## 참조변수와 인스턴스의 연결
- 멤버변수가 조상 클래스와 자손 클래스 동시에 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상클래스에 선언된 멤버변수, 자손타입의 참조변수를 사용했을 때는 자손클래스에 선언된 멤버변수가 사용

- 자손 클래스가 조상 클래스의 멤버를 중복으로 정의하지 않았을 때는 참조변수의 타입에 따른 변화가 없다

- 참조변수의 타입에 따라 결과가 달라지는 경우는 조상 클래스의 멤버변수와 같은 이름의 멤버변수를 자손 클래스에 중복해서 정의한 경우뿐

<br><br>

## 여러 종류의 객체를 배열로 다루기

Product p1 = new Tv();<br>
Product p2 = new Computer();<br>
Product p3 = new Audio();<br>
<br>
위의 코드를 Product타입의 참조변수 배열로 처리하면 아래와 같다<br>

Product p[] = new Product[3];<br>
p[0] = new Tv();<br>
p[1] = new Computer();<br>
p[3] = new Audio();<br><br>

- 조상타입의 참조변수 배열을 사용하면 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다
- 또는 묶어서 다루고 싶은 객체들의 상속관계를 따져 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다

370p~374p 다시 해보기

<br><br>

# 추상메서드
## 추상클래스란 ?
- 추상클래스는 미완성 설계도에 비유가능, 미완성 메서드(추상메서드)를 포함하고 있다는 뜻

- 추상클래스로는 인스턴스를 생성할 수 없고, 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다

- 추상클래스는 새로운 클래스를 작성하는데 있어 방법이 되는 조상클래스로서 중요한 의미를 가진다

- 추상클래스는 키워드 'abstract'를 붙이기만 하면 된다

abstract class 클래스이름 {<br>...<br>}

<br><br>

### 추상메서드(abstract method)
- 메서드는 선언부, 구현부(몸통)로 구성
  
- 선언부만 작성하고 구현부는 작성하지 않은 채 남긴 것이 추상메서드
  - 설계만 해놓고 실제 수행될 내용은 작성하지 않아서 미완성 메서드

- 조상 클래스에서 선언부만을 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려주고 내용은 상속받는 클래스에서 구현

- 추상메서드는 앞에 'abstract'를 붙여주고, 추상메서드는 구현부가 없으니 {} 대신 ;를 적어준다

/* 주석을 통해 어떤 기능을 수행할 목적으로 작성됐는지 알려준다 */<br>
abstract 리턴타입 메서드이름();<br><br>

- 추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해줘야한다<br><br>조상으로 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해야한다

<br><br>

### 추상클래스의 작성
- 상속이 자손 클래스를 만드는 데 조상 클래스를 사용하는 거라면<br>반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상클래스를 만드는 것

추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업<br>
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

- 추상클래스도 생성자가 있어야한다

- 굳이 abstract를 붙여 추상메서드로 선언하는 이유는 자손클래스에서 추상메서드를 반드시 구현하도록 강요하기 위함

<br><br>

# 인터페이스(interface)
### 인터페이스란
- 인터페이스는 일종의 추상클래스

- 추상클래스보다 추상화 정도가 높아 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다
- 추상클래스는 부분적으로 완성된 '미완성설계도' 라면<br>인터페이스는 구현된 것은 아무것도없고 밑그림만 그려져 있는 '기본 설계도' 라고 할 수 있다
<br><br>

### 인터페이스의 작성
- 인터페이스를 작성하는 것은 클래스랑 같다, 키워드로 class대신 interface를 사용한다

- 클래스와 같이 접근제어자로 public, default를 사용할 수 있다

<br>
interface 인터페이스이름{ <br>public static final 타입 상수이름 = 값;<br> public abstract 메서드이름{매개변수목록}<br>
}

- 모든 멤버변수는 public static final 이어야하며, 생략가능
- 모든 메서드는 public abstract 여야하며 생략가능

<br><br>

### 인터페이스의 상속
- 인터페이스는 인터페이스로부터만 상속받을 수 있다
- 다중상속이 가능하다
- 클래스 상속과 마찬가지로 조상 인터페이스에 정의된 멤버를 모두 상속받는다


<br><br>

### 인터페이스의 구현
- 클래스는 확장한다는 의미인 extends 사용
- 인터페이스는 구현한다는 의미인 implements 사용
- 만약 인터페이스의 메서드 중 일부만 구현했다면 abstract를 붙여 추상클래스로 선언해야함
- 상속과 구현을 동시에 할 수 있다

<br>
참고 - 인터페이스의 이름은 able로 끝나는거 추천

<br><br>
- 오버라이딩할때 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야하니 예시에서 public 지정

<br><br>

### 인터페이스를 이용한 다중 상속

- 인터페이스는 static상수만 정의할 수 있다

- TV클래스, VCR클래스가 있을 떄 TVCR 클래스를 작성하기 위해 한 쪽을 선택하여 상속받고 나머지 한쪽은 클래스 내에 포함시켜 내부적으로 인스턴스를 생성해서 사용

385p, 386p 참고

<br><br>

### 인터페이스를 이용한 다형성
- 자손 클래스의 인스턴스를 조상타입의 참조변수로 참조하는 게 가능

- 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스 참조가능
- 인터페이스 타입으로의 형변환도 가능

<br>
Fightable f = (Fightable)new Fighter();

<br><br>

- 인터페이스는 메서드의 매개변수의 타입으로 사용될 수 있다
  - void attack(Fightable f){<br>//...<br>}
- 인터페이스 타입의 매개변수가 가지는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공
- 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것도 가능
- 
<br><br>
★★★ 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미

<br><br>

### 인터페이스의 장점
- 개발시간을 단축시킬 수 있다
- 표준화가 가능하다
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다
- 독립적인 프로그래밍이 가능하다

<br><br>

### 인터페이스의 이해
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽 (Provider)이 있다
- 메서드를 사용하는 쪽에서는 사용할려는 메서드의 선언부만 알면 된다(내용은 몰라도 된다)

- 두 클래스간 관계를 간접적으로 변경하기 위해서는 먼저 인터페이스를 이용해 클래스(Provider)의 선언과 구현을 분리해야한다(397p, 398p)

<br><br>

### 디폴트 메서드와 static메서드
JDK1.8부터 디폴트메서드, static메서드를 추가할 수 있게 됨

<br>

- 인터페이스와 관련된 static메서드는 별도의 클래스에 따로 두어야 한다
<br>

#### 디폴트 메서드
- 인터페이스에 메서드를 추가한다는 것은 추상메서드를 추가한다는 것 -> 해당 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야하기 때문에 디폴트 메서드 제작 및 사용

- 디폴트 메서드 : 추상 메서드의 기본적인 구현을 제공하는 메서드
- 추상메서드가 아니기때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경안해도 된다

- 디폴트 키워드 앞에는 default를 붙인다, 일반 메서드처럼 뒤에 {}작성, 접근제어자 public 생략가능

<br>
기존<br>
interface MyInterface{<br>void method();<br>void newMethod(); //추상메서드<br>}<br><br>디폴트메서드<br>interface MyInterface{<br>void method();<br>default void newMethod(){}<br>}

<br><br><br>

# 내부 클래스(inner class)
- 내부 클래스는 클래스 내에 선언
- 한 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스의 멤버들 간에 서로 쉽게 접근
- 외부에 불필요한 클래스를 감춤으로 코드의 복잡성을 줄일 수 있다


<br>
내부 클래스의 장점

- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다
- 코드의 복잡성을 줄일 수 있다(캡슐화)

<br><br>

### 내부 클래스의 종류와 특징
- 내부 클래스의 종류는 변수의 선언 위치에 따른 종류와 같다
- 내부 클래스는 변수를 선언하는 것과 같은 위치에 선언할 수 있다
- 내부 클래스도 선언위치에 따라 인스턴스 클래스, 스태틱 클래스, 지역 클래스, 익명 클래스로 분류된다

<br><br>

내부 클래스 | 특 징
--- | ---
인스턴스 클래스<br>(instance class) | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스 멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다
스태틱 클래스<br>(static class) | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스으 ㅣstatic멤버처럼 다뤄진다, 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다
지역 클래스<br>(local class) | 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다
익명 클래스<br>(annoymous class) | 클래스의 선언되 객체의 생성을 동시에 하는 이름없는 클래스(일회용)

<br><br>

### 내부 클래스의 선언
- 변수가 선언된 위치에따라 인스턴스 변수,   클래스변수, 지역변수로 나뉘듯 내부 클래스도   선언된 위치에 따라 나뉜다

<br>

class Outer{<br>int iv = 0; <br>static int cv = 0;<br>void myMethod(){<br>int lv = 0;<br>}<br>}

<br><br>

class Outer{<br>class InstanceInner{}<br>static class StaticInner{}<br>void myMethod(){<br>class LocalInner{}<br>}<br>}


<br><br>

### 내부 클래스의 제어자와 접근성
- 인스턴스 클래스와 스태틱 클래스는 외부클래스의 멤버변수와 같은 위치에 선언, 멤버변수와 같은 성질을 가진다

- static클래스만 static멤버를 정의할 수 있다

<br>

- 인스턴스 클래스는 외부클래스의 인스턴스 멤버를 객체생성 없이 바로 사용할 수 있지만, 스태틱 클래스는 외부클래스의 인스턴스멤버를 객체생성 없이 바로 사용할 수 없다

- 마찬가지로 인스턴스 클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만, 스태틱 클래스에서는 인스턴스 클리스의 멤버들을 객체생성 없이 사용할 수 없다
