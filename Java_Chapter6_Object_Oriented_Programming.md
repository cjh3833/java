# 객체지향 프로그래밍 I
헷갈리는 것, 중요한 것 위주 정리

## 객체지향 언어
- 코드의 재사용성이 높다
    - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성

- 코드의 관리가 용이하다
    - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드 변경
- 신뢰성이 높은 프로그래밍 가능


## 클래스와 객체의 정의와 용도

1. 클래스의 정의 : 클래스란 객체를 정의해 놓은 것 <br>클래스의 용도 : 클래스는 객체를 생성하는데 사용된다

2. 객체의 정의 : 실제로 존재하는 것, 사물 또는 개념<br>객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

<br>

클래스 | 객체
---|---
제품 설계도 | 제품
TV설계도 | TV


<br><br>

## 객체와 인스턴스
- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 한다

- 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다

- 클래스 -> (인스턴스화) -> 인스턴스(객체)

<br><br>

## 객체의 구성요소 - 속성과 기능
- 객체는 속성과 기능 두 종류로 구성
- 클래스는 객체를 정의, 객체의 모든 속성과 기능 정의

- 속성(property) : 멤버변수, 특성
- 기능(function) : 메서드, 함수

<br>

변수 | 속성 | 크기, 길이, 높이, 색상, 볼륨,채널
--- | --- | ---
메서드 | 기능 | 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경 등등
<br><br>

## 인스턴스의 생성과 사용

- 클래스명 변수명;<br> 변수명 = new 클래스명();

- Tv t;<br> t = new Tv();

1. Tv t; <br>Tv클래스 타입의 참조변수 t 를 선언, 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 없다
2. t = new Tv();<br> Tv클래스의 인스턴스가 메모리의 빈 공간에 생성, 이 때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화

<br>

- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다

- t.channel = 7; <br> t : 참조변수 <br>channel : 멤버변수

<br><br>

## 객체 배열
- 객체 배열 안에 객체의 주소가 저장, 객체 배열은 참조변수들은 하나로 묶은 참조변수 배열

- Tv[] tvArr = new Tv(3); //참조변수 배열(객체 배열)을 생성<br>tvArr[0] = new Tv();<br>tvArr[1] = new Tv();<br>tvArr[2] = new Tv(); // 각 객체를 생성해서 배열의 각 요소에 저장
<br><br>

## 클래스의 또 다른 정의
- 클래스는 '객체를 생성하기 위한 틀', 클래스는 속성과 기능으로 정의
<br><br>

1. 클래스 - 데이터와 함수의 결합
   - 변수 -> 배열 -> 구조체 -> 클래스
   - 클래스 : 데이터와 함수의 결합(구조체 + 함수)

2. 클래스 - 사용자정의 타입
    - 기본형의 개수는 8개
    - 참조형의 개수는 정해지지않음, 새로운 타입을 만들 수 있다

<br><br>

비객체지향적 코드 | 객체지향적 코드
--- | ---
int hour1, hour2, hour3; <br>int min1, min2, min3;<br> float second1, second2, second3; | Time t1 = new Time();<br>Time t2 = new Time(); <br>Time t3 = new Time();

<br><br><br>

## 변수와 메서드

- 변수는 클래스변수, 인스턴스변수, 지역변수 총 3가지가 있다

- 멤버변수를 제외한 변수는 지역변수이다

- 멤버변수에서 static이 붙은 것은 클래스변수, 아닌 것은 인스턴스변수이다.

<br>

변수의 정류 | 선언위치 | 생성시기
--- | --- | ---
클래스변수 | 클래스영역 | 클래스가 메모리에 올라갈 때
인스턴스변수 | 클래스영역 | 인스턴스가 생성되었을 때
지역변수 | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때

<br><br>

1. 인스턴스변수
    - 클래스 영역에 선언
    - 클래스의 인스턴스를 생성할 때 만들어진다
    - 독립적인 저장공간을 가지니 서로 다른 값을 가질 수 있다
<br>

2. 클래스변수
    - 클래스 변수를 선언하는 방법은 인스턴스변수 앞에 static을 붙이면 된다
    - 클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유
    - 인스턴스변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용가능<br> '클래스이름.클래스변수' 같은 형식으로 사용
    - public을 앞에 붙이면 전역변수의 성격을 가진다

<br>

3. 지역변수
    - 메서드 내의 선언되어 메서드 내에서만 사용 가능, 메서드가 종료되면 소멸


<br><br>

## 클래스변수와 인수턴스변수

속성 | 무늬<br>숫자<br><br>폭<br>높이
--- | ---
기능 | ...

<br>

- class Card{<br>String kind; <br> int number; //인스턴스 변수<br><br>static int width = 100;<br>static int height = 250; // 클래스 변수<br>}

<br>

- 무늬,숫자는 각자 다르므로 인스턴스변수로 선언<br>카드의 폭, 높이는 모든 인스턴스가 같은 값을 가져야하니 클래스 변수로 선언


- 클래스 변수를 사용할 때는 Card.width와 같이<br>'클래스이름.클래스변수' 의 형태로 사용하는게 좋다

- 인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가진다.

<br><br>

## 메서드
- 메서드, 함수

- 메서드를 사용하는 이유
    1. 높은 재사용성
        - 한번 만들어 놓은 메서드는 여러번 호출가능, 다른프로그램에서도 사용가능

    2. 중복된 코드의 제거
        - 메서드로 만들어 사용하면 코드의 중복제거, 문제 발생시 이 메서드만 수정하면 되니 관리쉽고 오류의 발생가능성이 낮아짐
    3. 프로그램의 구조화
        - main 메서드는 프로그램의 전체 흐름이 한 눈에 들어올 정도로 단순하게 구조화하는 것이 좋다


<br><br>

## 메서드의 선언과 구현
  

### 매개변수 선언

#### 메서드의 이름
- 메서드의 이름은 'add'처럼 동사인 경우가 많으며, 이름만으로 메서드의 기능을 쉽게 알 수 있도록 함축적이며 의미있는 이름으로 사용

#### 반환타입
- 메서드의 작업수행 결과인 반환값의 타입을 적는다<br>반환값이 없는 경우 void를 적어야한다

<br>

#### return문
- 메서드 반환타입이 'void'가 아닌 경우, 구현부{}안에 'return 반환값;' 이 반드시 포함
- return문은 하나의 값만 반환 가능

<br>

## 메서드의 호출

- 메서드이름(값1, 값2...)<br>int result = add(3,5);

### 인자와 매개변수
- 메서드를 호출할 때 괄호()안에 지정하준 값들을 인저 또는 인수라고 하는데, 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함

<br>

### 메서드의 실행흐름
- MyMath mm = new Mymath();<br><br>long value = mm.add(1L, 2L);<br><br>long add(long a, long b) {<br>long result = a+b;<br>return result;<br>}

<br><br>

## return문
- 반한괎의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야함

- 반환 타입이 void인 경우 return문 생략가능

- 반환값이 있는 경우 반드시 return문이 있어야한다

<br>

### 매개변수 유효성 검사
- 구현할 때 매개변수의 값이 적절한 것인지 확인, 가능한 모든 경우의 수를 고민하고 그에 대비한 코드를 작성해야한다

<br><br>

### JVM 메모리 구조
1. 메서드 영역(method area)
   - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.calss)를 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이 곳에 저장한다
   - 클래스의 클래스변수도 이 영역에 함께 생성된다
  
2. 힙
   - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다<br>인스턴스 변수들이 생성되는 공간이다


3. 호출스택
   - 메서드의 작업에 필요한 메모리 공간을 제공한다
   - 메모리 할당, 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과를 저장하는데 사용
   - 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환
   - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드
   - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드

### 기본형 매개변수와 참조형 매개변수
- 매개변수의 타입이 기본형이라면 기본형의 값을 복사
- 매개변수의 타입이 참조형이라면 인스턴스의 주소를 복사

<br>

기본형 매개변수 | 변수의 값을 읽기만 할 수 있다 (read only)
--- | ---
참조형 매개변수 | 변수의 값을 읽고 변경할 수있다(read & write)

- java 264, 265p 참고

<br><br>

- 배열도 객체와 같이 참조변수를 통해 데이터가 저장된 공간에 접근

- 기본형 : 참조형,배열

<br><br>

### 참조형 반환 타입

- 반환타입이 참조형이면 반환하는 값의 타입도 참조형
- 반환타입이 참조형이라는 것은 메서드가 객체의 주소를 반환

<br><br>

### 재귀호출
- 메서드 내부에서 자신을 다시 호출하는 것이 재귀호출
- 재귀호출을 하는 메서드를 재귀 메서드라고 부름
  
- 호출된 메서드는 원래의 값이 아닌 복사된 값으로 작업, 호출한 메서드와 관계없이 독립적 작업수행 가능
- 재귀호출도 조건문이 필수적으로 따라다님

- 수행 시간이 반복문 < 재귀호출 이므로 반복문이 복잡할 시 논리적 간결함을 위해 쓸 수 있다

<br><br>

### 클래스 메서드(static 메서드) 와 인스턴스 메서드
- 메서드 앞에 static이 붙어 있으면 클래스메서드 / 붙어 있지 않으면 인스턴스 메서드

- 인스턴스 메서드는 인스턴스 변수와 관련한 작업, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요하는 메서드

- 인스턴스와 관련없는 메서드를 클래스 메서드(static 메서드)로 정의

- 클래스 영역 내 선언된 변수를 멤버변수<br>멤버변수중 static이 붙으면 클래스변수, 없으면 인스턴스 변수


##
1. 클래스를 설계할 때 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다
3. 클래스 변수(static변수)는 인스턴스 변수를 사용할 수 없다
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다

- 클래스 멤버 변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면 static을 붙여준다
- 작성한 메서드 중 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려

<br><br>

### 클래스 멤버와 인스턴스 멤버간의 참조와 호출
- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고 서로 참조 또는 호출 가능
- 클래스 멤버가 인스턴스 멤버를 참조, 호출할 때는 인스턴스를 생성해야함

- 인스턴스 멤버는 반드시 객체를 생성한 후에만 참조, 호출이 가능하니 클래스 멤버가 인스턴스 멤버를 참조, 호출하기 위해서는 객체를 생성해야 한다

<br><br>

## 오버로딩(overloading)

### 오버로딩이란?
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩, 오버로딩 이라 함
<br><br>

### 오버로딩의 조건
- 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야한다

1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다

### 오버로딩의 예
보기1.<br>int add(int a, int b) { return a+b };<br>int add(intx, int y) { return x+y };<br>(에러)
<br><br>

보기2. <br>int add(int a, int b) { return a+b };<br>
long add(int b, int a) { return b + a}<br>에러
<br><br>

보기3. <br>long add(int a, long b) { return a+b}; <br>
long add(long a, int b) { return a+b};<br>작동o
<br><br>

### 오버로딩의 장점
- 이름 절약, 메서드 이름을 보고 역할 유추가능
  
- System.out.println("mm.add(3,3)결과 : " + mm.add(3.3));
  <br>-> long add(int a, int b) - mm.add(3,3) 결과 : 6

- println메서드가 결과를 출력할려면 add메서드의 결과가 먼저 계산되어야하기 떄문에 저런식으로 결과가 나옴

- 아래 코드는 같은 역할
1. int result = mm.add(3,3);<br>System.out.println("mm.add(3,3)결과 : " + result);

2. System.out.println("mm.add(3,3)결과 : " + mm.add(3.3));

### 가변 인자와 오버로딩

- 기존 메서드의 매개변수 개수는 고정적이였지만 JDK1.5부터는 동적으로 지정가능, 이 기능을 '가변인자'라고 한다

- 가변인자는 '타입... 변수명' 와 같은 식으로 선언
   - public PirntStream printf(String format, Object...args) {...}
- 가변인자 외에 매개변수가 더 있으면, 가변인자를 맨 마지막에 선언해줘야한다

- 가변인자는 내부적으로 배열을 이용, 가변인자가 선언된 메서드를 호출할 때 마다 배열이 새로 생성
- 가변인자로 매개변수를 선언했기 때문에 문자열을 개수의 제약없이 매개변수로 지정할 수 있다

<br><br>

## 생성자(Constructor)
### 생성자란?
- 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'

생성자의 조건
1. 생성자의 이름은 클래스의 이름과 같아야한다
2. 생성자는 리턴값이 없다

Card 클래스의 인스턴스를 생성하는 코드를 예<br><br>
Card c = new Card();<br>
1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다
2. 생성자 Card()가 호출되어 수행된다
3. 연산자 new의 결과로 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다

- 인스턴스를 생성할 때는 반드시 클래스 내의 정의된 생성자 중 하나를 지정해줘야함

<br><br>

### 기본 생성자
- 컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 클래스 내 생성자가 하나도 없을 때
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다

<br><br>

### 매개변수가 있는 생성자

<br><br>

### 생성자에서 다른 생성자 호출하기 - this(), this
- 생성자의 이름으로 클래스이름 대신 this를 사용한다
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능

- 예시 this.color = color; <br> this.color는 인스턴스 변수이고, color는 생성자의 매개변수로 정의되니 지역변수
- this는 참조변수로 인스턴스 자신을 가르킨다
- this를 사용할 수 있는 건 인스턴스멤버뿐
- stathc메서드에서는 인스턴스 멤버들을 사용할 수 없는 것처럼 this역시 사용불가
<br><br>

### 생성자를 이용한 인스턴스의 복사

Car c1 = new Car();<br>Car c2 = new Car(c2);<br><br>
- 인스턴스 c2는 c1을 복사하여 생성된 것<br>서로 독립적으로 메모리 공간에 존재하는 별도의 인스턴스
  
- Car(Car c){<br>color = c.color;<br>gearType = c.gearType<br>door = cdoor;<br>}

- Car(Car c){<br>//Car(String color, String gearType, int door)<br>this(c.color, c.gearType, c.door);<br>}

- 인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야한다
    1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
    2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

## 변수의 초기화
### 변수의 초기화
- 멤버변수는 초기화를 하지 않아도 자동으로 변수의 자료형에 맞는 기본값으로 초기화
- 지역변수는 사용전 무조건 초기화

- 멤버변수(클래스 변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다

<br>

- 멤버 변수의 초가화 방법
    1. 명시적 초기화
    2. 생성자
    3. 초기화 블럭
        - 인스턴스 초기화 블럭
        - 클래스 초기화 블럭


<br><br>

### 명시적 초기화
- 변수를 선언과 동시에 초기화하는 것을 명시적 초기화
- 보다 복잡한 초기화 작업이 필요할 땐 초기화블럭 또는 생성자 사용

<br><br>

### 초기화 블럭
- 클래스 초기화 블럭
    - 클래스 변수의 복잡한 초기화에 사용
- 인스턴스 초기화 블럭
    - 인스턴스 변수의 복잡한 초기화에 사용


- 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행
- 인스턴스 초기화 블럭은 생성자처럼 인스턴스를 실행할 때 마다 수행

<br>
class InitBlock{<br>static { /*클래스 초기화 블럭*/ }<br>{ /*인스턴스 초기화 블럭 */ }<br>}

- 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다

<br><br>

### 멤버변수의 초기화 시기와 순서

- 클래스 변수의 초기화 시점
  - 클래스가 처음 로딩될 때 단 한번 초기화 된다
- 인스턴스 변수의 초기화 시점
  - 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다

<br>

- 클래스 변수의 초기화 순서
  - 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서
  - 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자