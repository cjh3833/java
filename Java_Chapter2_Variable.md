# Java Chapter 2. 변수
헷갈리는 부분, 중요한 부분 정리
- 변수는 '기본형' 과 '참조형' 2가지로 나눌 수 있습니다
1. 기본형(primitive type)
    - 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
    - 계산을 위한 실제 값을 저장합니다, 모두 8개

2. 참조형(reference type)
   - 객체의 주소를 저장합니다, 8개의 기본형을 제외한 나머지 타입

| 분류   | 타입 |
| --- | --- |
|논리형| true와 false 중 하나를 값으로 가지며, 조건식과 논리적 연산에 사용|
|문자형| 문자를 저장하는데 사용, 변수에 하나의 문자만 저장가능|
|정수형| 정수를 저장하는데 사용되며, 주로 int가 사용. byte는 이진 데이터를 다룰 때 사용되며. short은 c언어와의 호환을 위해 추가
|실수형| 실수를 저장하는데 사용되며, 주로 double이 사용.|
---

<br>
<br>

__기본 자료형의 종류와 크기는 반드시 외워야 한다__
| 크기 | 1 Byte | 2 Byte | 4 Byte | 8 Byte |
| ---  | --- | --- | --- | --- |
|논리형 | boolean
|문자형 | | char
|정수형 | byte | short | __int__ | long
|실수형 | | |float | __double__
---
<br>
<br>

## 리터럴
1. 정수형 리터럴
   - long 타입의 리터럴에는 접미사 'l', 'L'을 붙이고 없으면 int 타입의 리터럴이다
   - 10진수 외에도 2, 8, 16진수를 변수로 저장가능
   - int outNum = 010; //8진수 10, 10진수로 8
   - int hexNum = 0x10; //16진수 10, 10진수로 16
   - int binNum = 0b10; //2진수 10, 10진수로 2

2. 실수형 리터럴
    - float 타입의 티러럴에는 'f', 'F'<br> double형 타입의 리터럴에서는 'd', 'D'
    - float pi = 3.14f<br>double rate = 1.618d;
    - 실수형에서는 double이 기본 자료형이라 접미사 'd'는 생략가능하다

<br>

| 자료형 | 실수형 리터럴 | 다른형태의 동등한 표현 |
| --- | --- | --- |
double | 10. | 10.0
double | .10 | 0.10
float | 10f | 10.0f
float | 3.14e3f | 3140.0f
double | 1e1 | 10.0
double | 1e-3 | 0.001

<br><br>

## 문자열 리터럴과 문자열 리터럴

 - 7 + 7 + "" -> 14 + "" -> "14" + "" -> "14"
 - "" + 7 + 7 -> "7" + 7 -> "7" + "7" -> "77"

<br><br>


## 형식화된 출력 - printf()

printf() 지시자중 자주 사용되는 것들

지시자 | 설명
--- | ---
%b | 불리언(boolean) 형식으로 출력
%d | 10진(deciaml) 정수의 형식으로 출력
%o | 8진(octal) 정수의 형식으로 출력
%x, %X | 16진(hexa-decimal) 정수의 형식으로 출력
%f | 부동 소수점(floating-point) 의 형식으로 출력
%e, %E | 지수(exponent) 표현식의 형식으로 출력
%c | 문자(character) 로 출력
%s | 문자열(string) 로 출력
---
<br>

num = 10;
- System.out.printf("a = [%5d]\n", num); => [   10]
- System.out.printf("a = [%-5d]\n, num); => [10   ]
- System.out.printf("a = [%05d]\n, num); => [00010];

<br>
10진수를 2진수로 출력해주는 지시자는 없기 떄문에, 정수를 2진 문제열로 변환시켜주는 "Integer.toBinaryString(int i)"를 사용, 정수를 2진수로 변환해서 문자열로 반환하므로 "%s" 를 사용

- System.out.printf("binNum = %s\n", Integer.toBinaryString(int i));

<br>
C언어에서 char 타입의 값을 지시자 '%d'로 출력할 수 있지만<br>
자바에서는 허용되지 않으므로 int타입으로 형변환해야 '%d'로 출력할 수 있다

- System.out.printf("c = %c, %d\n, c, (int)c");

<br>
'%f'는 기본적으로 소수점 아래 6자리까지만 출력, 소수점 아래 7자리에서 반올림
<br> ex) 1.23456789 => 1.234568
<br><br>

__%전체자리.소수점아래자리f__
<br>
System.out.printf("d = %14.10f\n", d); //전체 14자리중 소수점 아래 10자리

1|2|3|4|1|2|3|4|5|6|7|8|9|0
---|---|---|---|---|---|---|---|---|---|---|---|---|---
| | |1|.|2|3|4|5|6|7|8|9|0|0|
---
왼쪽은 빈자리를 공백으로 채워줍니다<br>
오른쪽은 빈자리를 0으로 채워줍니다 <br>
<참고> 지시자를 '%014.10' 으로 지정했다면, 양쪽 빈자리를 모두 0으로 채웠을 것이다

<br>
- System.out.printf("[%s]\n", url); //문자열 길이만큼 출력공간을 확보
- System.out.printf("[%20s]\n", url); //최소 20글자 출력공간 확보. (우측정렬)
- System.out.printf("[%-20s]\n", url); //최소 20글자 출력공간 확보. (좌측정렬)
- System.out.printf("[%.8s]\n", url); //왼쪽에서 8글자만 출력

<br>

## 화면에서 입력받기 - Scanner
Scanner 클래스를 사용하려면, import문 하나 추가해줘야한다 <br>
- import java.util.*; //Scanner 클래스를 사용하기 위해 추가

그 뒤 클래스 객체를 생성해줍니다
- Scanner scan = new Scanner(System.in);

nextLine() 이라는 메서드를 호출하면, 입력대기 상태에 있다가 입력을 끝내고 엔터키를 누르면 입력한 내용이 문자열로 반환된다
- String input = scanner.nextLine();
- int num = Integer.parseInt(input);

이 때 입력받은 문자열을 숫자로 변환할려면 Integer.parseInt() 메서드를 사용해야한다

<br><br>

## 진법

bit => 1bit<br>
byte => 8bit<br>
word => 32bit or 64bit<br><br>
\*word 주의점\*
- 32비트 CPU에서는 1word == 32bit == 4btye
- 64비트 CPU에서는 1word == 64bit == 8btye

<br><br>

2진수 | 8진수 | 10진수 | 16진수
 --- | --- | --- | ---
0 | 0 | 0 | 0
1 | 1 | 1 | 1
10 | 2 | 2 | 2
11 | 3 | 3 | 3
100 | 4 | 4 | 4
101 | 5 | 5 | 5
110 | 6 | 6 | 6
111 | 7 | 7 | 7
1000 | 10 | 8 | 8
1001 | 11 | 9 | 9
1010 | 12 | 10 | A
1011 | 13 | 11 | B
1100 | 14 | 12 | C
1101 | 15 | 13 | D
1110 | 16 | 14 | E
1111 | 17 | 15 | F
10000 | 20 | 16 | 10
---

<br><br>
2진수를 8진수, 16진수로 변환<br>
-> 2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 변환<br>
-> 2진수를 뒤에서부터 4자리씩 끊어서 그에 해당하는 16진수로 변환

<br>
실수의 진법변환<br>
ex) 0.625

1. 0.625 * 2 = 1.25
1. 0.25 * 2 = 0.5
1. 0.5 * 2 = 1.0
1. 0.625(10) => 0.101(2)

정수부만을 위에서 아래로 순서대로 적고 0.을 앞에 붙이면 된다

<br><br>

## 기본형

### 1. 논리형 - boolean

1. 논리형은 'boolean' 한가지밖에 없다, true, flase중 하나를 저장할 수 있으며 디폴트는 false값 이다 <br>
2. 1bit만으로 충분하지만 자바에서는 데이터를 다루는 최소단위가 byte이므로 boolean의 크기가 1byte이다
<br><br>

### 2. 문자형 - char
1. 문자형은 'char' 한 가지 자료형뿐이다
2. char 타입의 변수는 단 하나의 문자만을 저장할 수 있다
3. 어떤 문자의 유니코드를 알고 싶으면, char형 변수에 저장된 값을 정수형으로 변환하면 된다

<br>

특수 문자 | 문자 리터럴
--- | ---
tab | \t
backspace | \b
form feed | \f
new line | \n
carriage return | \r
역슬래쉬(\) | \\\
작은 따음표 | \\'
큰 따음표 | \\"
유니코드(16진수)문자 | \u유니코드 (예: char a='\u0041') 

<br>
char 타입의 크기는 2byte(16bit)이므로 2진수 65535의 코드를 사용가능<br>
ex) 문자 'A'를 저장하면 아래와 같이 2진수 '0000000001000001'(10진수로 65)로 저장


<br>

### 3. 정수형 - byte, short, int, long
1. 범위 : 2^(n-1) ~ 2^(n-1)-1<br>
2. 정수형 변수를 선언할 때는 int타입으로 하고, int의 범위(약 +-20억)을 넘어서는 수를 다룰 때는 long을 사용한다
3. byte나 short은 성능보다 저장공간을 절약하는 게 중요할 때 사용

#### 정수형의 오버플로우해당
해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우<br>
최대값 + 1 -> 최소값<br>
최소값 - 1 -> 최대값

1|1|1|1
---|---|---|---
+| | |1
0|0|0|0
<br>

0|0|0|0
---|---|---|---
-| | | 1
1|1|1|1

<br>

#### 부호있는 정수의 오버플로우
부호없는 10진수 | 2진수 | 부호있는 10진수
:---: | --- | :---: |
0 | 0000 | 0
1 | 0001 | 1
2 | 0010 | 2
3 | 0011 | 3
4 | 0100 | 4
5 | 0101 | 5
6 | 0110 | 6
7 | 0111 | 7
8 | 1000 | -8
9 | 1001 | -7
10 | 1010 | -6
11 | 1011 | -5
12 | 1100 | -4
13 | 1101 | -3
14 | 1110 | -2
15 | 1111 | -1
0 | 0000 | 0
1 | 0001 | 1
2 | 0010 | 2

<br>

- 부호있는 10진수는 7, -8에서 오버플로우 발생
- 부호없는 10진수는 15, 0에서 오버플로우 발생

short타입은 -2^(n-1) ~ 2^(n-1)-1<br>
char 타입은 0 ~ 2^(n-1)
<br>

### 4. 실수형 - float, double
1. 실수형은 실수를 저장하기위한 타입으로 float와 double 두 가지가 있으며 각 타입의 변수에 저장할 수 있는 값의 범위는 아래 표 참조

타입 | 저장 가능한 값의 범위(양수) | 정밀도 | 크기
--- | --- | --- | ---
float | 1.4 * 10^-45 ~ 3.4 * 10^38 | 7자리 | byte : 4
double | 4.9 * 10^-324 ~ 1.8 * 10^308 | 15자리 | byte : 8
---

<br>

2. 실수형은 소수점수도 표현해야하니 '얼마나 큰 수를 표현할 수 있는가' 그리고 '얼마나 0에 가깝게 표현할 수 있는가' 도 중요하다

- int : 1 + 31 = 32(4 btye)
   - S(1) + 31bit
- float : 1 + 8 + 23 = 32(4 byte)
   - S(1) + E(8) + M(23)
- 부호(S), 지수(E), 가수(M)

float 타입은 정밀도가 7 <br>
double 타입은 정밀도가 15 <br>
실수형을 저장할 때 '보다 높은 정밀도'가 필요할 때는 double 타입 변수 사용

#### 실수형의 저장형식
- 실수형은 정수형과 표현방식이 달라서, 실수형은 값을 부동소수의 형태로 저장
- 부동소수점수는 실수를 +-M*2^e와 같은 형태로 표현하는 것을 말한다
- 부동소수는 부호(Sign), 지수(Exponent), 가수(Mantissa) 모두 세 부분으로 이루어져있다

- float : 1 + 8 + 23 = 32 (4btye)
   - S(1) + E(8) + M(23)
 - doubel : 1 + 11 + 52 = 64 (8btye)
   - S(1) + E(11) + M(52)

<br>

기호 | 의미 | 설명
--- | --- | ---
S | 부호(Sign bit) | 0이면 양수, 1이면 음수
E | 지수(Exponent) | 부호있는 정수, 지수의 범위는 -127~128(float), -1023 ~ 1024 (double)
M | 가수(Mantissa) | 실제 값을 저장하는 부분, 10진수로 7자리(float), 15자리(double)의 정말도로 저장 가능
---

<br>

__정규화__<br>
9.1234567 => 1.xxxx<br>
1001.0001111... =>(정규화) 1.001000111....


<br><br>

## 형변환
- 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- (타입)피연산자
   - double d = 85.4;
   - int score = (int)d;  //score = 85, d = 85.4

- 기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능

변환 | 수식 | 결과
:---: | :---: | :---:
int -> char | (char) 65 | 'A'
char -> int | (int) 'A' | 65
float -> int | (int) 1.6f | 1
int -> float | (float) 10 | 10.0f
---
<br>

### 정수간의 형변환
- 큰 타입에서 작은 타입으로의 변환 ex) int타입을 btye타입으로 변환할 경우 경우에 따라 값손실이 발생할 수 있다
  
- 작은 타입에서 큰 타입으로의 변환은 저장공간 부족으로 인한 값손실이 발생하지않는다

- 값을 채우고 난 뒤 빈 공간은 0으로 채우지만 음수일 경우 빈 공간은 1로 채운다 -> 형변환 후에도 부호를 유지하기 위함

<br>

### 실수형 간의 형변환
- float 타입의 값을 double타입으로 변환하는 경우
  - 지수(E)는 float의 기저인 127을 뺸 후 double의 기저인 1023을 더해서 변환하고, 가수(M)는 float의 가수 23자리를 채우고 남은 자리를 0으로 채운다
  
- double타입에서 float타입으로 변환하는 경우
  - 지수(E)는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더하고 가수(M)는 52자리 중 23자리만 저장되고 나머지는 버려진다
  
  - 주의할 점은 형변환할 때 가수의 24번째 자리에서 반올림이 발생할 수 있다

<br>

### 정수형과 실수형 간의 형변환

#### 정수형을 실수형으로 변환
- 정수를 2진수로 변환하고 정규화를 거쳐 실수의 저장형식으로 저장

- 실수형은 정수형보다 훨씬 큰 저장범위를 가지니 변환하는 것은 별 무리없다
- float형은 7자리까지의 정밀도만 제공하니 8자리 이상은 double형을 써주면 된다

<br>

#### 실수형을 정수형으로 변환
- 실수형을 정수형으로 형변환할 때 반올림이 발생하지 않는다
  - 실수 1.666을 int로 형변환하면 1이 된다

- 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는 정수의 오버플로우가 발생한 결과는 얻는다
  - int 91234567 -> 실수형 변환 후 int로 형변환 -> int 91234568

<br>

### 자동 형변환
- 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생한다

- 이 때 명시적으로 형변환 해줬을 경우 의도적인것으로 간주. 컴파일러는 에러를 발생시키지 않는다

- 서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입일치 시킨 후 계산

- 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다