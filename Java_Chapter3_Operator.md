# Java Chapter 3. 연산자
헷갈리는 것, 중요한 것 위주 정리

### 연산자와 피연산자
- 연산자(operator) 연산을 수행하는 기호 (+, -, *, /등)
- 피연산자(operand) 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)

1. 산술 > 비교 > 논리 > 대입 . 대입은 제일 마지막에 수행된다
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다

<br><br>

### 산술 변환

산술 변환의 규칙
1. 두 연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
    - long + int -> long + long -> long
    - float + int -> float + float -> float
    - double + float -> double + double -> double
  
2. 피연사자의 타입이 int 보다 작은 타입이면 int로 변환된다.
   - byte + short -> int + int -> int
   - char + short -> int + int -> int

산술 변환 - 연산 수행 직전에 발생하는 피연산자의 자동 형변환

<br><br>

### 단항 연산자
#### 증감연산자 ++ --

- 증감 연산자 (++) : 피연산자의 값을 1 증가시킨다
- 감소 연산자 (--) : 피연산자의 값을 1 감소시킨다
  
- 피연산자의 왼쪽에 위치하면 전위형, 오른쪽에 위치하면 후위형

타입 | 설명 | 사용예
--- | --- | ---
전위형 | 값이 참조되기 전에 증가시킨다. | j = ++i;
후위형 | 값이 참조된 후에 증가시킨다. | j = i++;
---

 - 독립적으로 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다
 -  ++i; //i의 값을 1 증가시킨다.
 -  i++; //위와 같다
  
<br>

int i = 5, j = 0; <br>
j = i++;

i = 5, j = 0; <br>
j = ++i;

- 처음 i = 6; j = 5;
- 밑 i = 6 j = 6;

<br><br>

### 문자열 비교
- 두 문자열을 비교할 때는 비교연산자 "==" 대신 equals() 라는 메소드 사용
- equals()는 비교하는 두 문자열이 같으면 true, 다르면 false 반환
<br><br>

### 비트연산자 & | ^ ~ << >>

- | (OR연산자) 피연산자 중 한 쪽의 값이 1이면 1을 결과로 얻는다, 그외는 0을 얻는다
- & (AND연산자) 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다, 그외에는 0을 얻는다
- ^ (XOR연산자) 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다, 같을 때는 0을 얻는다

x | y | x\|y | x&y | x^y
--- | --- | --- | --- | ---
1 | 1 | 1 | 1 | 0
1 | 0 | 1 | 0 | 1
0 | 1 | 1 | 0 | 1
0 | 0 | 0 | 0 | 0
---

<br>

#### 비트 전환 연산자 ~
- 2진수로 표현했을 때 0ㅇ,ㄴ 1로, 1은 0으로 바꾼다, 논리연산자 ! 와 유사하다
- 부호가 반대로 변경되니 즉 피연산자의 1의 보수를 얻을 수 있다
  
- 비트 전환 연산자 == 1의 보수 연산자

- 0 0 0 0 1 0 1 0 => 10
- 1 1 1 1 0 1 0 1 => -11

<br>

#### 쉬프트 연산자 << >>

- 8 << 2 는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다

    1. 10진수 8은 2진수로 '00001000'
    2. 8 << 2 은 10진수 8의 2진수를 왼쪽으로 2자리 이동시킨다, <br>'001000  '
    3. 저장범위를 벗어난 값은 버려지고 빈 자리는 0으로 채워진다<br>'00100000'
    4. 8 << 2의 결과는 2진수로 '00100000'이 된다(10진수로 32)

<br>

- x << n 은 x*(2^n)의 결과와 같다
- x >> n은 x /(2^n)의 결과와 같다

- 쉬프트 연산자가 속도가 빠르긴 해도 곱셈, 나눗셈 연산자보다 가독성이 떨어진다
- 보다 빠른 실행속도가 요구되어지는 곳에서만 쉬프트 연산자를 사용하는 것이 좋다

<br><br>

#### 조건 연산자 ?:
- 조건식 ? 식1 : 식2
- 조건식이 참이면 식1, 거짓이면 식2